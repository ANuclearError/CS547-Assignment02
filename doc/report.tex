\documentclass[11pt, a4paper]{article}
\usepackage[parfill]{parskip}
\usepackage[margin=1in]{geometry}
\usepackage{url}

\setlength\parindent{0pt}

\begin{document}
\title{CS547 Advanced Topics in Computer Science\\
\large{Assignment 02 - Test Case Prioritisation}}
\author{Aidan O'Grady - 201218150}
\date{}
\maketitle

\section{Overview}
\label{sec:overview}
The task given was to implement a genetic algorithm and hill climber for the
purposes of solving the test case prioritisation problem. We were provided two
files containing test case data to be prioritised, one small and one large. In
addition, a base line random search was also required to act as a baseline
comparison for the other search implementations.

\section{Problem Representation}
\label{sec:problem_representation}
The \emph{TestCase} class was created to contain the data that was read from the
files, containing the list of faults found by the test as well the potential
number of tests that could be found. This allowed for the coverage of that test
to also be contained.

The \emph{TCChromosome} class is the class used by the search algorithms,
containing the fitness function, crossover and mutation methods that are required
for the search algorithms. The \emph{TCChromosome} class (hereafter referred to
as the \emph{Chromosome} class) stores a List of TestCases that is the
candidate. A List was chosen to allow for easier manipulation of the candidate
in cases of crossover and mutation, since cases could easily be swapped and
changed for other test cases.

\subsection{Fitness Function}
\label{sub:fitness_function}
The fitness function utilised is a slightly modified version of the APFD measure
outlined by Elbaum et al \cite[Section~4.1]{Elbaum:2002:TCP:506201.506205}.
While their implementation ranges from 0 to 1 (being a percentage calculation),
my solution is inverted, meaning that a fitness function of 0 would be the best
outcome. This was done to allow for my search algorithms to have an
understandable terminate condition by comparing the fitness values to 0. 

In addition, my fitness function can break beyond the range of APFD. This occurs
when a fault is not found within any of the test cases within the candidate, due
to the summation that occurs within the fitness function calculation. In
addition, due to the need for better results to have a lower fitness value, the
APFD is deducted from 1 to ensure this.

\subsection{Crossover Method}
\label{sub:crossover}
The choice for crossover was taken from Harman et al
\cite[Section~5.1]{Harman:2012:SSE:2379776.2379787}. Crossover is contained in
the Chromosome class, taking in the other parent and index as parameters. The
original Chromosome's list of test cases is copied into a new list up to the
given index. This is followed by iterating through the other parent's list of
cases, and inserting from it until the list is filled. This is then used to
create and return a new chromosome.

\subsection{Mutation Method and Neighbourhood}
\label{sub:mutation}
The mutation method and neighbourhood are very similar to each other, being used
by Genetic Algorithm and Hill Climber respectably to progress in their searches,
so it was natural to be consistent between them.

The original method was by swapping test cases in the candidate, with both
swapping adjacent test cases or any test cases being considered. However, I did
not feel that this was a great solution to go with, since I felt that it not
introducing new test cases meant that progress would be slower, increasing the
number of random restarts in hill climbing for example.

Walcott et al \cite[Figure~4a]{Walcott:2006:TTS:1146238.1146240} provided an
alternative that I felt was more suitable to the problem at hand. Instead, a
random test case in the list is replaced with a random test case from the pool
of test cases. By using this method of mutation instead, I felt that the
algorithms would be more effective.

The neighbourhood function for hill climber is similar, although for each
neighbour, it looks at the cases surrounding the case to be replaced in the
pool of tests determined by the given size of step. For example, if the test
case being replaced was number 150, and the step size was 10, then test cases
140-149 and 151-160 would replace it for each neighbour.

\section{Implementation}
\label{sec:implementation}
\subsection{Reading the Data}
\label{sub:reading_data}
The format of the data files given to us was less than ideal. A regular
expression was made to make the file parsing a lot easier, since I merely had to
iterate upon the matches to the expression. When examining the data file, one
feature that was of interest was the fact that there are many cases that were
repeated. For example, in the small data file, unittest0 to unitest30 all had
the exact same coverage. This meant that when performing the algorithms, there
was the potential for waste in cases such as swapping two test cases that were
the same. In order to combat this, the TestCase class ignores the name of the
test when comparing between two objects, allowing for the file parsing to return
a Set of TestCases rather than a List, greatly reducing the number of
permutations possible for chromosomes.

\subsection{Terminating Searches}
\label{sub:terminating}
In comparison to the `Hello World' exercise, the issue of terminating searches
was more complex due to the nature of the problem meaning that a fitness of 0
was not guaranteed to be possible, meaning that the termination of searches had
to be more sophisticated. In order to account for the impact the data set and
configuration have on calculating the fitness function, I felt that a raw
fitness value to terminate on would be less than ideal. This meant that each
search implementation needed to handle termination in their own way.

\subsection{Interfaces}
\label{sub:interfaces}
There are two interfaces that are utilised by all search algorithms. These are
the \emph{Search} and \emph{Result} interfaces. The \emph{Search} interface
provides definitions for the \emph{search} and \emph{benchmark} methods, while
the \emph{Result} interface is an empty interface that was required so that the
\emph{search} method mentioned would have consistency in the return.

\subsection{Random Search}
\label{sub:random_search}
Random search is naturally rather straightforward. Its limit is provided in the
configuration file, and it will repeatedly generate new chromosomes until this
limit is found. This implementation of Random Search keeps a record of the best
chromosome found, and only replaces it if an improved solution is found. The
\emph{Result} returned contains the chromosome and the counter indicating when
it was found.

\subsection{Hill Climbing}
\label{sub:hill_climbing}
The hill climbing is performed by starting with a random chromosome, and then
investigating its neighbours (see \ref{sub:mutation}) to find improvements. If
no improvement is found, then the algorithm restarts at a new random location.
The random restart is used to determine when to terminate the search. If the
best solution is found, then its neighbours are obviously not able to improve
upon it. This means that we need to prevent the random restart. This is done by
ensuring the new restart is better than the current best, with continuous
attempts to find a better solution randomly (similar to random search). A limit
is added to ensure that if no better solution is found, the search terminates.

\subsection{Genetic Algorithm}
\label{sub:genetic_algorithm}
The genetic algorithm is done utilising the \emph{TCPopulation} class. When the
population evolves, the new population is taking from the top percentage of
chromosomes, with the configuration file stating how elite to be. Parents are
determined using tournament selection, with crossover and mutation being
performed if they meet a check (defined in the configuration file).

There will eventually reach a point where no improvements can be made, and the
generations' best chromosome never changes. A limit is provided to help
terminate the search. Every time the search doesn't improve, a counter is
incremented. If the limit is reached, then the search is terminated, and the
result is returned. The returned object takes the limit into account, meaning
that if the limit was 250, then the result 250 generations that were spawned are
ignored.

\newpage
\section{Comparison}
\subsection{Random Search Results}
\subsection{Hill Climb Search Results}
\subsection{Genetic Algorithm Search Results}

\bibliographystyle{plain}
\bibliography{report} 
\end{document}